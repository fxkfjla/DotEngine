#pragma once

#include "dot_Device.h"
#include "dot_Swapchain.h"

#include "Shader.h"

#include <vector>
#include <string>

namespace dot
{
    struct PipelineConfig
    {
        PipelineConfig() = default;
        PipelineConfig(const PipelineConfig&) = delete;
        PipelineConfig(const PipelineConfig&&) = delete;
        PipelineConfig& operator=(const PipelineConfig&) = delete;
        PipelineConfig& operator=(const PipelineConfig&&) = delete;

        std::vector<vk::VertexInputBindingDescription> bindingDescriptions;     // describes at which rate to load data from memory throughout the vertices, specifies the number of bytes between data entries and whether to move to the next data entry after each vertex or after each instance
        std::vector<vk::VertexInputAttributeDescription> attributeDescriptions; // describes how to extract a vertex attribute from a chunk of vertex data originating from a binding description
        vk::PipelineVertexInputStateCreateInfo vertexStateInfo;                 // references binding and attribute descriptions 
        vk::PipelineInputAssemblyStateCreateInfo inputAssemblyStateInfo;        // determines topology: triangles, lines, points
        vk::PipelineTessellationStateCreateInfo tessellationStateInfo;          // the process of tessellation involves subdividing a patch of some type, then computing new vertex values (position, color, texture coordinates, etc.) for each of the vertices generated by this process.
        vk::PipelineViewportStateCreateInfo viewportStateInfo;                  // specifies parameters of the viewport
        vk::PipelineRasterizationStateCreateInfo rasterizationStateInfo;        // generates fragments (pixels) from the assembled polygons
        vk::PipelineMultisampleStateCreateInfo multisampleStateInfo;            // msaa (multisample anti aliasing), gives multiple samples for rasterization to reduce aliasing
        vk::PipelineDepthStencilStateCreateInfo stencilStateInfo;               // sets stencil value based on which we discard or keep fragments whenever a particular fragment has a certain stencil value
        vk::PipelineColorBlendAttachmentState colorBlendAttachmentState;        // after fragment shader returns a color, it needs to be combined with the color that is already in the framebuffer
        vk::PipelineColorBlendStateCreateInfo colorBlendStateInfo;              // sets blend constants
        std::vector<vk::DynamicState> dynamicStates;                            // determines which states of pipeline can be dynamically changed
        vk::PipelineDynamicStateCreateInfo dynamicStateInfo;                    // allows some changes to pipeline without need to rebuild               
        vk::PipelineLayoutCreateInfo layoutInfo;                                // information about push-constants and descriptors (ways to provide data to shaders)
        vk::RenderPass renderPass;                                              // in order to render, a render pass must be started. A Renderpass will render into a Framebuffer. The framebuffer links to the images you will render to, and itâ€™s used when starting a renderpass to set the target images for rendering
        uint32_t subpass;                                                       // splits the rendering operations of a render pass into subpasses. All subpasses in a render pass share the same resolution and tile arrangement, and as a result, they can access the results of previous subpass
    };

    class Pipeline
    {
    public:
        Pipeline(Device&, const std::string& vertShaderPath, const std::string& fragShaderPath, const PipelineConfig&);
        Pipeline(const Pipeline&) = delete;
        Pipeline(const Pipeline&&) = delete;
        Pipeline& operator=(const Pipeline&) = delete;
        Pipeline& operator=(const Pipeline&&) = delete;
        operator const vk::Pipeline&() const noexcept;
        ~Pipeline();

        static void defaultConfig(PipelineConfig&, const vk::RenderPass&);
    private:
        void createLayout(const PipelineConfig&);
        void createPipeline(const PipelineConfig&);

        Shader vertShader;
        Shader fragShader;
        vk::PipelineLayout layout;
        vk::Pipeline pipeline;

        Device& device;
    };
}